0:  touch .hello_there
1:  chmod -rw .hello_there
2:  σε αλλο terminal ενω τρεχει
    pidof riddle
    kill -SIGCONT pid
3:  export ANSWER = 42
4:  ltrace και export = 1 τις 2 μεταβλητες
    rm magic_mirror
    mkfifo magic_mirror
    In a FIFO pipe, a read after a write would always read the last byte that was just written.
    In a regular file the read after write reads the next byte.
    ./riddle
5:  ./ch5
6:  ./ch6
7:  ln .hello_there .hey_there
8:  ./ch8
9:  σε αλλο terminal
    sudo socat TCP4-LISTEN:49842 STDOUT
10: ln secret_number try.txt
11: ./ch11
12: ./ch12
13: chmod +rw .hello_there
    ./riddle
    Eνω τρεχει ./ch13 και γραψε κατι στο terminal του riddle
14: ./ch14

0:  openat(AT_FDCWD, ".hello_there", O_RDONLY) = -1 ENOENT (No such file or directory)

1:  openat(AT_FDCWD, ".hello_there", O_WRONLY)
    I found the doors unlocked. FAIL

2:  pause() = ? ERESTARTNOHAND (To be restarted if no handler)
    --- SIGALRM {si_signo=SIGALRM, si_code=SI_KERNEL} ---
    rt_sigreturn({mask=[]}) = -1 EINTR (Interrupted system call)

3:  getenv("ANSWER") = nil
    what is the answer to life the universe and everything?

4:  openat(AT_FDCWD, "magic_mirror", O_RDWR) = -1 ENOENT (No such file or directory)
    getenv("I_HATE_GAME_HINTS") = nil
    getenv("I_NEED_TECH_HINTS") = nil
    ---------------------------------
    openat(AT_FDCWD, "magic_mirror", O_RDWR) = 4
    write(4, "D", 1)                        = 1
    read(4, "", 1)                          = 0
    write(2, "\33[31mI cannot see my reflection."..., 42I cannot see my reflection. FAIL

5:  fcntl(99, F_GETFD) = -1 EBADF (Bad file descriptor)

6: strace -f ./riddle:
   [pid 19488] read(33, 0x7ffdbdf8922c, 4) = -1 EBADF (Bad file descriptor)
   [pid 19487] write(34, "\0\0\0\0", 4)    = -1 EBADF (Bad file descriptor)
   So 33 reads 4 bytes
      34 writes 4 bytes
   ----
   Καναμε με dup2 τους fd να δειχνουν σε αρχειο και
   [pid 19509] read(53, 0x7ffd0d57430c, 4) = -1 EBADF (Bad file descriptor)
   Καναμε με dup2 τον fd να δειχνουν σε αρχειο και μας εμφανισε οτι υπαρχει και fd 54 στον οποιο το εκτελεσιμο θελει να κανει write 4 bytes.


7:  lstat(".hey_there", 0x7ffd2bd31a90)     = -1 ENOENT (No such file or directory)
  =>touch .hey_there
    write(2, "Oops. 674986 != 674995.\n", 24Oops. 674986 != 674995.) = 24
    Λεει το hint hard links
  =>rm .hey_there

8:

9:

10:

11:

12:

13:

14:



13:
You will get SIGBUS if you attempt to write past the mapped region of the file.
Chances are pretty good that your backing store file accounts is truncated/too short. (e.g.) if the file has space for 10 struct entries and you write to the 11th, you'll get SIGBUS
Do an fstat to get st_size and compare this against the length parameter you're giving to mmap
You may want to consider using ftruncate to extend the file before doing mmap
